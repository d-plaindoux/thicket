/*
 * Thicket
 * https://github.com/d-plaindoux/thicket
 *
 * Copyright (c) 2015-2016 Didier Plaindoux
 * Licensed under the LGPL2 license.
 */
 
module Data.Tree
 
from Lang.When import *
from Data.Boolean import *
from Data.Number import *
 
type Tree[a] {
    Empty
    Node { depth: number value : a left : Tree[a] right : Tree[a] }    
}
 
class tree[a] this:Tree[a] {
    unbox : Tree[a]
    
    fold : [b] b -> (number -> tree[a] -> tree[a] -> b) -> b

    depth : number
    isEmpty : bool
    
    (+) : a -> tree[a]
    map : [b] (a -> b) -> tree[b]
} {
    def unbox = this
    
    def Empty.fold e _ = e
    def Node.fold _ f = f this.depth (tree this.left) (tree this.right)
    
    def depth = self fold 0 (l _ _ -> l)    
    def isEmpty = self fold true (_ _ _ -> false)
    
    def Empty.(+) a = tree $ Node 1 a Empty Empty
    def Node.(+) a = 
        when (tree this.left depth <? $ tree this.right depth)
        then (tree $ Node (this.depth + 1) this.value (tree this.left + a unbox) this.right)
        else (tree $ Node (this.depth + 1) this.value this.left (tree this.right + a unbox))
    
    def Empty.map _ = emptyTree
    def Node.map f = 
        let left = tree this.left map f unbox in
        let right = tree this.right map f unbox in
            tree $ Node this.depth (f this.value) left right
}
    
def emptyTree : tree = { tree Empty }
